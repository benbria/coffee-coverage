// Generated by CoffeeScript 1.5.0
(function() {
  var COFFEE_EXTENSION, CoverageError, JS_EXTENSION, abbreviatedPath, coffeeScript, defaultOptions, defaults, endsWith, events, fs, mkdirs, path, pkginfo, statFile, stripLeadingDot, util, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  coffeeScript = require('coffee-script');

  events = require('events');

  fs = require('fs');

  util = require('util');

  path = require('path');

  path.sep = path.sep || "/";

  _ref = require('./helpers'), endsWith = _ref.endsWith, defaults = _ref.defaults, abbreviatedPath = _ref.abbreviatedPath, mkdirs = _ref.mkdirs, stripLeadingDot = _ref.stripLeadingDot, statFile = _ref.statFile;

  pkginfo = require('pkginfo')(module, 'version', 'author', 'contributors');

  COFFEE_EXTENSION = ".coffee";

  JS_EXTENSION = ".js";

  CoverageError = (function(_super) {

    __extends(CoverageError, _super);

    function CoverageError(message) {
      this.message = message;
      this.name = "CoverageError";
      Error.call(this);
      Error.captureStackTrace(this, arguments.callee);
    }

    return CoverageError;

  })(Error);

  defaultOptions = {
    coverageVar: '_$jscoverage',
    exclude: [],
    recursive: true,
    bare: false
  };

  exports.CoverageInstrumentor = (function(_super) {
    var fileToLines, fixLocationData, generateUniqueName, nodeType, toQuotedString, validateSrcDest, writeToFile;

    __extends(CoverageInstrumentor, _super);

    function CoverageInstrumentor(options) {
      if (options == null) {
        options = {};
      }
      this.options = defaults(options, defaultOptions);
    }

    toQuotedString = function(string) {
      var answer;
      answer = string.replace(/\\/g, '\\\\');
      return '"' + (answer.replace(/"/g, '\\\"')) + '"';
    };

    fileToLines = function(fileData) {
      var dataWithFixedLfs;
      dataWithFixedLfs = fileData.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
      return dataWithFixedLfs.split("\n");
    };

    nodeType = function(node) {
      return node.constructor.name;
    };

    writeToFile = function(outFile, content) {
      return fs.writeFileSync(outFile, content);
    };

    validateSrcDest = function(source, out) {
      var outStat, sourceStat;
      sourceStat = statFile(source);
      outStat = out ? statFile(out) : null;
      if (!sourceStat) {
        throw new CoverageError("Source file " + source + " does not exist.");
      }
      if (outStat) {
        if (sourceStat.isFile() && outStat.isDirectory()) {
          throw new CoverageError("Refusing to overwrite directory " + out + " with file.");
        }
        if (sourceStat.isDirectory() && outStat.isFile()) {
          throw new CoverageError("Refusing to overwrite file " + out + " with directory.");
        }
      }
    };

    generateUniqueName = function(usedNames, desiredName) {
      var answer, suffix;
      answer = "";
      suffix = 1;
      while (true) {
        answer = desiredName + " (" + suffix + ")";
        if (!(__indexOf.call(usedNames, answer) >= 0)) {
          break;
        }
        suffix++;
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrument = function(source, out, options) {
      var sourceStat;
      validateSrcDest(source, out);
      sourceStat = statFile(source);
      if (sourceStat.isFile()) {
        return this.instrumentFile(source, out, options);
      } else if (sourceStat.isDirectory()) {
        return this.instrumentDirectory(source, out, options);
      } else {
        throw new CoverageError("Can't instrument " + source + ".");
      }
    };

    CoverageInstrumentor.prototype.instrumentDirectory = function(sourceDirectory, outDirectory, options) {
      var answer, file, inst, outDirectoryStat, outFile, outputDirectoryExists, sourceDirectoryMode, sourceFile, sourceStat, _i, _len, _ref1;
      if (options == null) {
        options = {};
      }
      this.emit("instrumentingDirectory", sourceDirectory, outDirectory);
      options.usedFileNames = options.usedFileNames || [];
      answer = {
        lines: 0
      };
      options = defaults(options, this.options);
      validateSrcDest(sourceDirectory, outDirectory);
      if (!endsWith(sourceDirectory, path.sep)) {
        sourceDirectory += path.sep;
      }
      if (!endsWith(outDirectory, path.sep)) {
        outDirectory += path.sep;
      }
      outDirectoryStat = statFile(outDirectory);
      outputDirectoryExists = !!outDirectoryStat;
      sourceDirectoryMode = (statFile(sourceDirectory)).mode;
      _ref1 = fs.readdirSync(sourceDirectory);
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        file = _ref1[_i];
        if (__indexOf.call(options.exclude, file) >= 0) {
          this.emit("skip", sourceDirectory + file);
          continue;
        }
        sourceFile = sourceDirectory + file;
        outFile = outDirectory + file;
        sourceStat = statFile(sourceFile);
        if (endsWith(file.toLowerCase(), COFFEE_EXTENSION) && sourceStat.isFile()) {
          if (!outputDirectoryExists) {
            mkdirs(outDirectory, sourceDirectoryMode);
            outputDirectoryExists = true;
          }
          outFile = outFile.slice(0, +(-(COFFEE_EXTENSION.length + 1)) + 1 || 9e9) + JS_EXTENSION;
          inst = this.instrumentFile(sourceFile, outFile, options);
          answer.lines += inst.lines;
        } else if (options.recursive && sourceStat.isDirectory()) {
          inst = this.instrumentDirectory(sourceFile, outFile, options);
          answer.lines += inst.lines;
        }
      }
      return answer;
    };

    CoverageInstrumentor.prototype.instrumentFile = function(sourceFile, outFile, options) {
      var answer, data, filename, _ref1;
      this.emit("instrumentingFile", sourceFile, outFile);
      validateSrcDest(sourceFile, outFile);
      switch (options.path) {
        case 'relative':
          filename = stripLeadingDot(sourceFile);
          break;
        case 'abbr':
          filename = abbreviatedPath(stripLeadingDot(sourceFile));
          break;
        default:
          filename = path.basename(sourceFile);
      }
      if (options.usedFileNames && __indexOf.call(options.usedFileNames, filename) >= 0) {
        filename = generateUniqueName(options.usedFileNames, filename);
      }
      if (options.usedFileNames) {
        options.usedFileNames.push(filename);
      }
      data = fs.readFileSync(sourceFile, 'utf8');
      answer = this.instrumentCoffee(filename, data);
      if ((_ref1 = options.initFileStream) != null) {
        _ref1.write(answer.init);
      }
      if (outFile) {
        writeToFile(outFile, answer.init + answer.js);
      }
      return answer;
    };

    fixLocationData = function(instrumentedLine, line) {
      var doIt;
      doIt = function(node) {
        return node.locationData = {
          first_line: line - 1,
          first_column: 0,
          last_line: line - 1,
          last_column: 0
        };
      };
      doIt(instrumentedLine);
      return instrumentedLine.eachChild(doIt);
    };

    CoverageInstrumentor.prototype.instrumentCoffee = function(fileName, fileData) {
      var ast, fileToInstrumentLines, index, init, instrumentTree, instrumentedLines, js, line, lineNumber, options, quotedFilename, _i, _j, _len, _len1;
      options = this.options;
      quotedFilename = toQuotedString(fileName);
      ast = coffeeScript.nodes(fileData);
      instrumentedLines = [];
      instrumentTree = function(node) {
        var childIndex, children, doAnnotation, expression, instrumentedLine, line, _results;
        if (nodeType(node) !== "Block") {
          return node.eachChild(function(child) {
            return instrumentTree(child);
          });
        } else {
          children = node.expressions;
          childIndex = 0;
          _results = [];
          while (childIndex < children.length) {
            expression = children[childIndex];
            line = expression.locationData.first_line + 1;
            doAnnotation = true;
            if (nodeType(expression) === "Comment") {
              doAnnotation = false;
            }
            if (__indexOf.call(instrumentedLines, line) >= 0) {
              doAnnotation = false;
            }
            if (doAnnotation) {
              instrumentedLines.push(line);
              instrumentedLine = coffeeScript.nodes("" + options.coverageVar + "[" + quotedFilename + "][" + line + "]++");
              fixLocationData(instrumentedLine, line);
              children.splice(childIndex, 0, instrumentedLine);
              childIndex++;
            }
            instrumentTree(expression);
            _results.push(childIndex++);
          }
          return _results;
        }
      };
      instrumentTree(ast);
      init = "if (typeof " + options.coverageVar + " === 'undefined') " + options.coverageVar + " = {};\nif ((typeof global !== 'undefined') && (typeof global." + options.coverageVar + " === 'undefined')) {\n    global." + options.coverageVar + " = " + options.coverageVar + "\n} else if ((typeof window !== 'undefined') && (typeof window." + options.coverageVar + " === 'undefined')) {\n    window." + options.coverageVar + " = " + options.coverageVar + "\n}\nif (! " + options.coverageVar + "[" + quotedFilename + "]) {\n    " + options.coverageVar + "[" + quotedFilename + "] = [];\n";
      for (_i = 0, _len = instrumentedLines.length; _i < _len; _i++) {
        lineNumber = instrumentedLines[_i];
        init += "    " + options.coverageVar + "[" + quotedFilename + "][" + lineNumber + "] = 0;\n";
      }
      init += "}\n\n";
      init += "" + options.coverageVar + "[" + quotedFilename + "].source = [";
      fileToInstrumentLines = fileToLines(fileData);
      for (index = _j = 0, _len1 = fileToInstrumentLines.length; _j < _len1; index = ++_j) {
        line = fileToInstrumentLines[index];
        if (!!index) {
          init += ", ";
        }
        init += toQuotedString(line);
      }
      init += "];\n\n";
      js = ast.compile({
        bare: options.bare
      });
      return {
        init: init,
        js: js,
        lines: instrumentedLines.length
      };
    };

    return CoverageInstrumentor;

  })(events.EventEmitter);

}).call(this);
